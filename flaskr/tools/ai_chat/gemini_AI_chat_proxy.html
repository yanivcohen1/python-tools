<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini chat</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <!-- Optional: Include CSS for Markdown styling -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <!-- Configure MathJax for LaTeX rendering using $ delimiters -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$'], ['\\begin{math}', '\\end{math}']], // for inline math patterns
        displayMath: [['\\[', '\\]'], ['$$', '$$'], ['\\begin{displaymath}', '\\end{displaymath}']], // for new line math patterns
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <!-- Include MathJax for svg use: https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js-->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #output {
      background-color: #f4f4f4;
      padding: 20px;
      border-radius: 10px;
      color: #333;
    }

    code {
      background-color: #e8e8e8;
      color: #d6336c;
      padding: 2px 4px;
      border-radius: 4px;
    }

    pre code {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 10px;
      border-radius: 10px;
      display: block;
    }

    h2 {
      margin: 5px 0; /* Adjust top and bottom margins as needed */
    }

    think {
      color: gray;
      display: none;
      /* display: none; */
    }

    /* hr {
        border: none;
        border-top: 3px double #333;
        color: #333;
        overflow: visible;
        text-align: center;
        height: 5px;
      }

      hr::after {
        background: #fff;
        content: "End Thinking";
        padding: 0 4px;
        position: relative;
        top: -13px;
      } */
      div.sticky {
        position: sticky;
        z-index: 10;
        bottom : 0;
        background-color: white;
        width: 100%;
        /* padding: 50px; #343a40;
           font-size: 20px; */
      }
  </style>
</head>

<body onload="getModelList()">
  <div id="output"></div>
  <div class="sticky">
    <h2>Ask Gemini</h2>
    <div>
      <div id="modelList"></div>
      <textarea id="inputMessage" rows="4" cols="50" placeholder="Enter your message here...">
  find the value of ( x ) that satisfies the equation ( 3 \sin(2x) + 4 \cos(2x) = 5 ).
  and also write py that plot the solved equation and the solutions using scipy root
      </textarea>
      <br>
      <button id="send" onclick="fetchCompletion()">Send</button>
      <span id="count"></span><br><br>

      <input type="text" id="messageInput" placeholder="Enter server simulte msg" />
      <button onclick="sendMessage()">Send</button>
      <h4>Server Messages:</h4>
      <ul id="messages"></ul>
    </div>
</body>

<script>
  let controller;
  let startTime = null;
  let content = "";
  const displayHandle = document.getElementById('output');
  const send_btn = document.getElementById('send')
  let intervalID = null;
  let chatHistory = [];
  let answer = ""
  let ws;
  let isConnected = false;

  function generateRandomUserId() {
      return 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
  }

  const userId = encodeURIComponent(generateRandomUserId());
  console.log(userId);

  function connectWebSocket() {
      ws = new WebSocket(`ws://localhost:7000/ws/${userId}`);

      ws.onopen = () => {
          console.log('WebSocket connected');
          isConnected = true;
      };

      ws.onmessage = function(event) {
          const messages = document.getElementById("messages");
          const message = document.createElement("li");
          message.textContent = event.data;
          messages.appendChild(message);
          const is_confirm = alert(event.data)
          ws.send(is_confirm + " - from " + userId);
      };

      ws.onclose = () => {
          console.log('WebSocket closed');
          isConnected = false;
      };

      ws.onerror = (err) => {
          console.error('WebSocket error:', err);
          // Optional: Close on error to ensure a clean reconnect
          ws.close();
          isConnected = false;
          // reconnect after short delay
          setTimeout(() => {
            if (document.visibilityState === 'visible' && !isConnected) {
              console.log('Reconnecting after error...');
              connectWebSocket();
            }
          }, 1000); // delay in ms
      };
  }

  function sendMessage() {
      const input = document.getElementById("messageInput");
      // ws.send(input.value);
      fetch(`/send_message?user_id=${userId}&msg=${encodeURIComponent(input.value)}`)
        .then(response => response.json())
        .then(data => {
          console.log(data); // Handle the response
        })
        .catch(error => {
          console.error('Error:', error);
        });
      input.value = "";
  }

  // Reconnect only if disconnected when tab becomes visible
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && !isConnected) {
      console.log('Page active and WebSocket disconnected. Reconnecting...');
      connectWebSocket();
    }
  });

  // Disable mangling so that any needed backslashes remain intact.
  marked.setOptions({
    mangle: false
  });

  async function getModelList() {
    try {
      document.getElementById('output').innerHTML = ""
      const response = await fetch('http://localhost:7000/models', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      if (!response.ok) {
        throw new Error('Failed to fetch model list');
      }

      const data = await response.json();

      const models = data;
      const modelListDiv = document.getElementById('modelList');
      modelListDiv.innerHTML = '';  // Clear any previous content

      // Create a select dropdown with model options
      const select = document.createElement('select');
      select.id = 'modelSelect';

      // Create a default option
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.text = 'Select a model';
      defaultOption.disabled = true;
      // defaultOption.selected = true;
      select.appendChild(defaultOption);

      // sort
      models.sort((a, b) => a.localeCompare(b))
      models.forEach((model) => {
        const option = document.createElement('option');
        option.value = model;
        option.text = model;
        if (model == 'gemini-2.0-flash-thinking-exp')
          option.selected = true;
        select.appendChild(option);
      });

      modelListDiv.appendChild(select);
      // document.getElementById("refresh_models").style.display = "none";

    } catch (error) {
      document.getElementById('output').innerHTML = 'Error on read ollama models:  ' + error
      console.error('Error:', error);
    }
  }

  async function fetchCompletion() {
    const modelSelect = document.getElementById('modelSelect')
    if (!modelSelect || !modelSelect.value) {
      alert('No model selected. Please select a model first.');
      return
    }
    const selectedModel = modelSelect.value;
    send = send_btn.innerHTML
    if (send == "Send") {
      send_btn.innerHTML = "Stop"
      send_btn.style.backgroundColor = "#555555"; // Black
      send_btn.style.color = "white"
      startTime = Date.now();
      document.getElementById("count").innerHTML = "";
      content += content=="" ? "" : "<br><br><hr><hr>" // new conversation
      let myMsg = document.getElementById('inputMessage').value;
      content += "<span><b>User: </b>" + myMsg + "</span>"
      content += "<hr>"
      answer = ""
    } else {
      // stop the call
      controller.abort();
      finish_and_calc_time();
      return
    }
    let myMsg = document.getElementById('inputMessage').value;
    chatHistory.push({ role: 'user', parts: [myMsg] });

    controller = new AbortController();
    const signal = controller.signal;
    const response = await fetch('http://localhost:7000/tools', {
      method: 'POST',
      keepalive: true,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        'model': selectedModel,//'deepseek-r1:8b',
        'prompt': myMsg,
        'user_id': userId,
      }),
      signal // Add signal here to support aborting
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let think = true;

    intervalID = setInterval(() => {
      update_display();
    }, 200); // Update every 2 seconds

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      content += text;
      answer += text;
      // Scroll to the bottom of the page
      window.scrollTo(0, document.body.scrollHeight || document.documentElement.scrollHeight);
    }
    finish_and_calc_time();
  }

  function update_display(){
    // Re-render MathJax content
    displayHandle.innerHTML = content;
    MathJax.typesetPromise([displayHandle]);
    // marked parse
    displayHandle.innerHTML = marked.parse(displayHandle.innerHTML);
    // Syntax highlighting
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  }

  function finish_and_calc_time() {
    clearInterval(intervalID);
    update_display();

    // Add the final response to chat history
    chatHistory.push({ role: 'model', parts: [answer] });

    // button reset
    send_btn.innerHTML = "Send"
    send_btn.style.backgroundColor = "#e7e7e7"; // gray
    send_btn.style.color = "black" // text color

    // Calculate elapsed time in minutes
    wordCount = content.trim().split(/\s+/).length;
    let elapsedTimeSec = (Date.now() - startTime) / 1000;
    let elapsedTimeMin = elapsedTimeSec / 60;

    // Calculate words per minute (avoid division by zero)
    let wpm = elapsedTimeSec > 0 ? (wordCount / elapsedTimeSec).toFixed(2) : 0;

    // Update the output div
    document.getElementById("count").innerHTML = `Time: ${elapsedTimeSec.toFixed(2)} sec, Words: ${wordCount}, WPS: ${wpm}`;
  }

  // Initial connection
  connectWebSocket();
</script>

</html>
