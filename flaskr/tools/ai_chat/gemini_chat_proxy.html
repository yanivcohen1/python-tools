<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini chat</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <!-- Optional: Include CSS for Markdown styling -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <!-- Configure MathJax for LaTeX rendering using $ delimiters -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['\\begin{math}', '\\end{math}']], // for inline math patterns
        displayMath: [['\\[', '\\]'], ['\\begin{displaymath}', '\\end{displaymath}']], // for new line math patterns
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <!-- Include MathJax for svg use: https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js-->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #output {
      background-color: #f4f4f4;
      padding: 20px;
      border-radius: 10px;
      color: #333;
    }

    code {
      background-color: #e8e8e8;
      color: #d6336c;
      padding: 2px 4px;
      border-radius: 4px;
    }

    pre code {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 10px;
      border-radius: 10px;
      display: block;
    }

    h2 {
      margin: 5px 0; /* Adjust top and bottom margins as needed */
    }

    think {
      color: gray;
      display: none;
      /* display: none; */
    }

    /* hr {
        border: none;
        border-top: 3px double #333;
        color: #333;
        overflow: visible;
        text-align: center;
        height: 5px;
      }

      hr::after {
        background: #fff;
        content: "End Thinking";
        padding: 0 4px;
        position: relative;
        top: -13px;
      } */
  </style>
</head>

<body onload="getModelList()">
  <div id="output"></div>
  <h2>Ask Gemini</h2>
  <div>
    <div id="modelList"></div>
    <textarea id="inputMessage" rows="4" cols="50" placeholder="Enter your message here...">
find the value of ( x ) that satisfies the equation ( 3 \sin(2x) + 4 \cos(2x) = 5 ).
and also write py that plot the solved equation and the solutions using scipy root
    </textarea>
    <br>
    <button id="send" onclick="fetchCompletion()">Send</button>
    <span id="count"></span>
</body>

<script>
  let controller;
  let startTime = null;
  let content = "";
  const displayHandle = document.getElementById('output');
  const send_btn = document.getElementById('send')
  let intervalID = null;
  let chatHistory = [];
  let answer = ""
  // Disable mangling so that any needed backslashes remain intact.
  marked.setOptions({
    mangle: false
  });

  async function getModelList() {
    try {
      document.getElementById('output').innerHTML = ""
      const response = await fetch('http://localhost:7000/models', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      if (!response.ok) {
        throw new Error('Failed to fetch model list');
      }

      const data = await response.json();

      const models = data;
      const modelListDiv = document.getElementById('modelList');
      modelListDiv.innerHTML = '';  // Clear any previous content

      // Create a select dropdown with model options
      const select = document.createElement('select');
      select.id = 'modelSelect';

      // Create a default option
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.text = 'Select a model';
      defaultOption.disabled = true;
      // defaultOption.selected = true;
      select.appendChild(defaultOption);

      // sort
      models.sort((a, b) => a.localeCompare(b))
      models.forEach((model) => {
        const option = document.createElement('option');
        option.value = model;
        option.text = model;
        if (model == 'gemini-2.0-flash-thinking-exp')
          option.selected = true;
        select.appendChild(option);
      });

      modelListDiv.appendChild(select);
      // document.getElementById("refresh_models").style.display = "none";

    } catch (error) {
      document.getElementById('output').innerHTML = 'Error on read ollama models:  ' + error
      console.error('Error:', error);
    }
  }

  async function fetchCompletion() {
    const modelSelect = document.getElementById('modelSelect')
    if (!modelSelect || !modelSelect.value) {
      alert('No model selected. Please select a model first.');
      return
    }
    const selectedModel = modelSelect.value;
    send = send_btn.innerHTML
    if (send == "Send") {
      send_btn.innerHTML = "Stop"
      send_btn.style.backgroundColor = "#555555"; // Black
      send_btn.style.color = "white"
      startTime = Date.now();
      document.getElementById("count").innerHTML = "";
      content += content=="" ? "" : "<br><br><hr><hr>" // new conversation
      let myMsg = document.getElementById('inputMessage').value;
      content += "<span><b>User: </b>" + myMsg + "</span>"
      content += "<hr>"
      answer = ""
    } else {
      // stop the call
      controller.abort();
      finish_and_calc_time();
      return
    }
    let myMsg = document.getElementById('inputMessage').value;
    chatHistory.push({ role: 'user', parts: [myMsg] });

    controller = new AbortController();
    const signal = controller.signal;
    const response = await fetch('http://localhost:7000/stream', {
      method: 'POST',
      keepalive: true,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        'model': selectedModel,//'deepseek-r1:8b',
        'prompt': chatHistory,
      }),
      signal // Add signal here to support aborting
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let think = true;

    intervalID = setInterval(() => {
      update_display();
    }, 200); // Update every 2 seconds

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      content += text;
      answer += text;
    }
    finish_and_calc_time();
  }

  function update_display(){
    // Re-render MathJax content
    displayHandle.innerHTML = content;
    MathJax.typesetPromise([displayHandle]);
    // marked parse
    displayHandle.innerHTML = marked.parse(displayHandle.innerHTML);
    // Syntax highlighting
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  }

  function finish_and_calc_time() {
    clearInterval(intervalID);
    update_display();

    // Add the final response to chat history
    chatHistory.push({ role: 'model', parts: [answer] });

    // button reset
    send_btn.innerHTML = "Send"
    send_btn.style.backgroundColor = "#e7e7e7"; // gray
    send_btn.style.color = "black" // text color

    // Calculate elapsed time in minutes
    wordCount = content.trim().split(/\s+/).length;
    let elapsedTimeSec = (Date.now() - startTime) / 1000;
    let elapsedTimeMin = elapsedTimeSec / 60;

    // Calculate words per minute (avoid division by zero)
    let wpm = elapsedTimeSec > 0 ? (wordCount / elapsedTimeSec).toFixed(2) : 0;

    // Update the output div
    document.getElementById("count").innerHTML = `Time: ${elapsedTimeSec.toFixed(2)} sec, Words: ${wordCount}, WPS: ${wpm}`;
  }
</script>

</html>
